{
  "version": 3,
  "sources": ["../../sweepline-intersections/dist/sweeplineIntersections.esm.js", "../../@turf/line-intersect/index.ts", "../../@turf/line-intersect/lib/sweepline-intersections-export.ts", "../../@turf/polygon-to-line/index.ts", "../../@turf/boolean-disjoint/index.ts", "../../@turf/boolean-intersects/index.ts"],
  "sourcesContent": ["class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction checkWhichEventIsLeft (e1, e2) {\n    if (e1.p.x > e2.p.x) return 1\n    if (e1.p.x < e2.p.x) return -1\n\n    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1\n    return 1\n}\n\nfunction checkWhichSegmentHasRightEndpointFirst (seg1, seg2) {\n    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1\n    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1\n\n    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1\n    return 1\n}\n\nclass Event {\n\n    constructor (p, featureId, ringId, eventId) {\n        this.p = {\n            x: p[0],\n            y: p[1]\n        };\n        this.featureId = featureId;\n        this.ringId = ringId;\n        this.eventId = eventId;\n\n        this.otherEvent = null;\n        this.isLeftEndpoint = null;\n    }\n\n    isSamePoint (eventToCheck) {\n        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y\n    }\n}\n\nfunction fillEventQueue (geojson, eventQueue) {\n    if (geojson.type === 'FeatureCollection') {\n        const features = geojson.features;\n        for (let i = 0; i < features.length; i++) {\n            processFeature(features[i], eventQueue);\n        }\n    } else {\n        processFeature(geojson, eventQueue);\n    }\n}\n\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature (featureOrGeometry, eventQueue) {\n    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n    let coords = geom.coordinates;\n    // standardise the input\n    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n    if (geom.type === 'LineString') coords = [[coords]];\n\n    for (let i = 0; i < coords.length; i++) {\n        for (let ii = 0; ii < coords[i].length; ii++) {\n            let currentP = coords[i][ii][0];\n            let nextP = null;\n            ringId = ringId + 1;\n            for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n                nextP = coords[i][ii][iii + 1];\n\n                const e1 = new Event(currentP, featureId, ringId, eventId);\n                const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n\n                e1.otherEvent = e2;\n                e2.otherEvent = e1;\n\n                if (checkWhichEventIsLeft(e1, e2) > 0) {\n                    e2.isLeftEndpoint = true;\n                    e1.isLeftEndpoint = false;\n                } else {\n                    e1.isLeftEndpoint = true;\n                    e2.isLeftEndpoint = false;\n                }\n                eventQueue.push(e1);\n                eventQueue.push(e2);\n\n                currentP = nextP;\n                eventId = eventId + 1;\n            }\n        }\n    }\n    featureId = featureId + 1;\n}\n\nclass Segment {\n\n    constructor (event) {\n        this.leftSweepEvent = event;\n        this.rightSweepEvent = event.otherEvent;\n    }\n}\n\nfunction testSegmentIntersect (seg1, seg2) {\n    if (seg1 === null || seg2 === null) return false\n\n    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId &&\n        (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false\n\n    const x1 = seg1.leftSweepEvent.p.x;\n    const y1 = seg1.leftSweepEvent.p.y;\n    const x2 = seg1.rightSweepEvent.p.x;\n    const y2 = seg1.rightSweepEvent.p.y;\n    const x3 = seg2.leftSweepEvent.p.x;\n    const y3 = seg2.leftSweepEvent.p.y;\n    const x4 = seg2.rightSweepEvent.p.x;\n    const y4 = seg2.rightSweepEvent.p.y;\n\n    const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    const numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    const numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) return false\n        return false\n    }\n\n    const uA = numeA / denom;\n    const uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        const x = x1 + (uA * (x2 - x1));\n        const y = y1 + (uA * (y2 - y1));\n        return [x, y]\n    }\n    return false\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck (eventQueue, ignoreSelfIntersections) {\n    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n\n    const intersectionPoints = [];\n    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n\n    while (eventQueue.length) {\n        const event = eventQueue.pop();\n        if (event.isLeftEndpoint) {\n            // debugEventAndSegments(event.p, outQueue.data)\n            const segment = new Segment(event);\n            for (let i = 0; i < outQueue.data.length; i++) {\n                const otherSeg = outQueue.data[i];\n                if (ignoreSelfIntersections) {\n                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue\n                }\n                const intersection = testSegmentIntersect(segment, otherSeg);\n                if (intersection !== false) intersectionPoints.push(intersection);\n            }\n            outQueue.push(segment);\n        } else if (event.isLeftEndpoint === false) {\n            outQueue.pop();\n            // const seg = outQueue.pop()\n            // debugRemovingSegment(event.p, seg)\n        }\n    }\n    return intersectionPoints\n}\n\nfunction sweeplineIntersections (geojson, ignoreSelfIntersections) {\n    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n    fillEventQueue(geojson, eventQueue);\n    return runCheck(eventQueue, ignoreSelfIntersections)\n}\n\nexport default sweeplineIntersections;\n", "import { feature, featureCollection, point } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport type { Intersection } from \"sweepline-intersections\";\nimport { sweeplineIntersections as findIntersections } from \"./lib/sweepline-intersections-export.js\";\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @function\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.removeDuplicates=true] remove duplicate intersections\n * @param {boolean} [options.ignoreSelfIntersections=true] ignores self-intersections on input features\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect<\n  G1 extends LineString | MultiLineString | Polygon | MultiPolygon,\n  G2 extends LineString | MultiLineString | Polygon | MultiPolygon,\n>(\n  line1: FeatureCollection<G1> | Feature<G1> | G1,\n  line2: FeatureCollection<G2> | Feature<G2> | G2,\n  options: {\n    removeDuplicates?: boolean;\n    ignoreSelfIntersections?: boolean;\n  } = {}\n): FeatureCollection<Point> {\n  const { removeDuplicates = true, ignoreSelfIntersections = true } = options;\n  let features: Feature<G1 | G2>[] = [];\n  if (line1.type === \"FeatureCollection\")\n    features = features.concat(line1.features);\n  else if (line1.type === \"Feature\") features.push(line1);\n  else if (\n    line1.type === \"LineString\" ||\n    line1.type === \"Polygon\" ||\n    line1.type === \"MultiLineString\" ||\n    line1.type === \"MultiPolygon\"\n  ) {\n    features.push(feature(line1));\n  }\n\n  if (line2.type === \"FeatureCollection\")\n    features = features.concat(line2.features);\n  else if (line2.type === \"Feature\") features.push(line2);\n  else if (\n    line2.type === \"LineString\" ||\n    line2.type === \"Polygon\" ||\n    line2.type === \"MultiLineString\" ||\n    line2.type === \"MultiPolygon\"\n  ) {\n    features.push(feature(line2));\n  }\n\n  const intersections = findIntersections(\n    featureCollection(features),\n    ignoreSelfIntersections\n  );\n\n  let results: Intersection[] = [];\n  if (removeDuplicates) {\n    const unique: Record<string, boolean> = {};\n    intersections.forEach((intersection) => {\n      const key = intersection.join(\",\");\n      if (!unique[key]) {\n        unique[key] = true;\n        results.push(intersection);\n      }\n    });\n  } else {\n    results = intersections;\n  }\n  return featureCollection(results.map((r) => point(r)));\n}\n\nexport { lineIntersect };\nexport default lineIntersect;\n", "// Get around problems with moduleResolution node16 and some older libraries.\n// Manifests as \"This expression is not callable ... has no call signatures\"\n// https://stackoverflow.com/a/74709714\n\nimport lib from \"sweepline-intersections\";\n\nexport const sweeplineIntersections = lib as unknown as typeof lib.default;\n", "import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { getGeom } from \"@turf/invariant\";\n\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @function\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nfunction polygonToLine<\n  G extends Polygon | MultiPolygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  poly: Feature<G, P> | G,\n  options: { properties?: any } = {}\n):\n  | Feature<LineString | MultiLineString, P>\n  | FeatureCollection<LineString | MultiLineString, P> {\n  const geom: any = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\n\n/**\n * @private\n */\nfunction singlePolygonToLine<\n  G extends Polygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  poly: Feature<G, P> | G,\n  options: { properties?: any } = {}\n): Feature<LineString | MultiLineString, P> {\n  const geom = getGeom(poly);\n  const coords: any[] = geom.coordinates;\n  const properties: any = options.properties\n    ? options.properties\n    : poly.type === \"Feature\"\n      ? poly.properties\n      : {};\n\n  return coordsToLine(coords, properties);\n}\n\n/**\n * @private\n */\nfunction multiPolygonToLine<\n  G extends MultiPolygon,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  multiPoly: Feature<G, P> | G,\n  options: { properties?: P } = {}\n): FeatureCollection<LineString | MultiLineString, P> {\n  const geom = getGeom(multiPoly);\n  const coords: any[] = geom.coordinates;\n  const properties: any = options.properties\n    ? options.properties\n    : multiPoly.type === \"Feature\"\n      ? multiPoly.properties\n      : {};\n\n  const lines: Array<Feature<LineString | MultiLineString, P>> = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\n\n/**\n * @private\n */\nfunction coordsToLine<P extends GeoJsonProperties = GeoJsonProperties>(\n  coords: number[][][],\n  properties: P\n): Feature<LineString | MultiLineString, P> {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\n\nexport { polygonToLine, coordsToLine, multiPolygonToLine, singlePolygonToLine };\nexport default polygonToLine;\n", "import {\n  Feature,\n  Geometry,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\n\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @function\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreSelfIntersections=true] ignore self-intersections on input features\n * @returns {boolean} true if the intersection is an empty set, false otherwise\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry,\n  {\n    ignoreSelfIntersections = true,\n  }: {\n    ignoreSelfIntersections?: boolean;\n  } = { ignoreSelfIntersections: true }\n): boolean {\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(\n        flatten1.geometry,\n        flatten2.geometry,\n        ignoreSelfIntersections\n      );\n    });\n  });\n  return bool;\n}\n\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @param {boolean} ignoreSelfIntersections ignore self-intersections on input features\n * @returns {boolean} true if disjoint, false otherwise\n */\nfunction disjoint(geom1: any, geom2: any, ignoreSelfIntersections: boolean) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\n\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString: LineString, pt: Point) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (\n      isPointOnLineSegment(\n        lineString.coordinates[i],\n        lineString.coordinates[i + 1],\n        pt.coordinates\n      )\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isLineOnLine(\n  lineString1: LineString,\n  lineString2: LineString,\n  ignoreSelfIntersections: boolean\n) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections,\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isLineInPoly(\n  polygon: Polygon,\n  lineString: LineString,\n  ignoreSelfIntersections: boolean\n) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections,\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @param {boolean} ignoreSelfIntersections ignore self-intersections on input features\n * @returns {boolean} true if geom1 is in geom2, false otherwise\n */\nfunction isPolyInPoly(\n  feature1: Polygon,\n  feature2: Polygon,\n  ignoreSelfIntersections: boolean\n) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2),\n    { ignoreSelfIntersections }\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isPointOnLineSegment(\n  lineSegmentStart: Position,\n  lineSegmentEnd: Position,\n  pt: Position\n) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\n\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true if coord pairs match, false otherwise\n */\nfunction compareCoords(pair1: Position, pair2: Position) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexport { booleanDisjoint };\nexport default booleanDisjoint;\n", "import { Feature, Geometry } from \"geojson\";\nimport { booleanDisjoint } from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n\n/**\n * Boolean-intersects returns (TRUE) if the intersection of the two geometries is NOT an empty set.\n *\n * @function\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreSelfIntersections=true] ignore self-intersections on input features\n * @returns {boolean} true if geometries intersect, false otherwise\n * @example\n * var point1 = turf.point([2, 2]);\n * var point2 = turf.point([1, 2]);\n * var line = turf.lineString([[1, 1], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point1);\n * //=false\n *\n * turf.booleanIntersects(line, point2);\n * //=true\n *\n * //addToMap\n * var addToMap = [point1, point2, line];\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n */\nfunction booleanIntersects(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry,\n  {\n    ignoreSelfIntersections = true,\n  }: {\n    ignoreSelfIntersections?: boolean;\n  } = {}\n) {\n  let bool = false;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === true) {\n        return true;\n      }\n      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {\n        ignoreSelfIntersections,\n      });\n    });\n  });\n  return bool;\n}\n\nexport { booleanIntersects };\nexport default booleanIntersects;\n"],
  "mappings": "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",
  "names": ["featureId", "ringId", "eventId", "sweeplineIntersections", "lineString"]
}
