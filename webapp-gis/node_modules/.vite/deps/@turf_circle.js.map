{
  "version": 3,
  "sources": ["../../@turf/destination/index.ts", "../../@turf/circle/index.ts"],
  "sourcesContent": ["// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { Feature, Point, GeoJsonProperties } from \"geojson\";\nimport {\n  Coord,\n  degreesToRadians,\n  lengthToRadians,\n  point,\n  radiansToDegrees,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @function\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination<P extends GeoJsonProperties = GeoJsonProperties>(\n  origin: Coord,\n  distance: number,\n  bearing: number,\n  options: {\n    units?: Units;\n    properties?: P;\n  } = {}\n): Feature<Point, P> {\n  // Handle input\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n\n  // Main\n  const latitude2 = Math.asin(\n    Math.sin(latitude1) * Math.cos(radians) +\n      Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)\n  );\n  const longitude2 =\n    longitude1 +\n    Math.atan2(\n      Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n      Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)\n    );\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n  if (coordinates1[2] !== undefined) {\n    return point([lng, lat, coordinates1[2]], options.properties);\n  }\n  return point([lng, lat], options.properties);\n}\n\nexport { destination };\nexport default destination;\n", "import { GeoJsonProperties, Feature, Point, Polygon } from \"geojson\";\nimport { destination } from \"@turf/destination\";\nimport { polygon, Units } from \"@turf/helpers\";\n\n/**\n * Takes a {@link Point} and calculates the circle polygon given a radius in {@link https://turfjs.org/docs/api/types/Units Units}; and steps for precision.\n *\n * @function\n * @param {Feature<Point>|number[]} center center point\n * @param {number} radius radius of the circle\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} circle polygon\n * @example\n * var center = [-75.343, 39.984];\n * var radius = 5;\n * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};\n * var circle = turf.circle(center, radius, options);\n *\n * //addToMap\n * var addToMap = [turf.point(center), circle]\n */\nfunction circle<P extends GeoJsonProperties = GeoJsonProperties>(\n  center: number[] | Point | Feature<Point, P>,\n  radius: number,\n  options: {\n    steps?: number;\n    units?: Units;\n    properties?: P;\n  } = {}\n): Feature<Polygon, P> {\n  // default params\n  const steps = options.steps || 64;\n  const properties: any = options.properties\n    ? options.properties\n    : !Array.isArray(center) && center.type === \"Feature\" && center.properties\n      ? center.properties\n      : {};\n\n  // main\n  const coordinates = [];\n  for (let i = 0; i < steps; i++) {\n    coordinates.push(\n      destination(center, radius, (i * -360) / steps, options).geometry\n        .coordinates\n    );\n  }\n  coordinates.push(coordinates[0]);\n\n  return polygon([coordinates], properties);\n}\n\nexport { circle };\nexport default circle;\n"],
  "mappings": ";;;;;;;;;;;;;AAuCA,SAAS,YACP,QACA,UACA,SACA,UAGI,CAAC,GACc;AAEnB,QAAM,eAAe,SAAS,MAAM;AACpC,QAAM,aAAa,iBAAiB,aAAa,CAAC,CAAC;AACnD,QAAM,YAAY,iBAAiB,aAAa,CAAC,CAAC;AAClD,QAAM,aAAa,iBAAiB,OAAO;AAC3C,QAAM,UAAU,gBAAgB,UAAU,QAAQ,KAAK;AAGvD,QAAM,YAAY,KAAK;IACrB,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,OAAO,IACpC,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,UAAU;EACjE;AACA,QAAM,aACJ,aACA,KAAK;IACH,KAAK,IAAI,UAAU,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,SAAS;IAC7D,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,SAAS;EAC9D;AACF,QAAM,MAAM,iBAAiB,UAAU;AACvC,QAAM,MAAM,iBAAiB,SAAS;AACtC,MAAI,aAAa,CAAC,MAAM,QAAW;AACjC,WAAO,MAAM,CAAC,KAAK,KAAK,aAAa,CAAC,CAAC,GAAG,QAAQ,UAAU;EAC9D;AACA,SAAO,MAAM,CAAC,KAAK,GAAG,GAAG,QAAQ,UAAU;AAC7C;;;AChDA,SAAS,OACP,QACA,QACA,UAII,CAAC,GACgB;AAErB,QAAM,QAAQ,QAAQ,SAAS;AAC/B,QAAM,aAAkB,QAAQ,aAC5B,QAAQ,aACR,CAAC,MAAM,QAAQ,MAAM,KAAK,OAAO,SAAS,aAAa,OAAO,aAC5D,OAAO,aACP,CAAC;AAGP,QAAM,cAAc,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,gBAAY;MACV,YAAY,QAAQ,QAAS,IAAI,OAAQ,OAAO,OAAO,EAAE,SACtD;IACL;EACF;AACA,cAAY,KAAK,YAAY,CAAC,CAAC;AAE/B,SAAO,QAAQ,CAAC,WAAW,GAAG,UAAU;AAC1C;AAGA,IAAO,gBAAQ;",
  "names": []
}
